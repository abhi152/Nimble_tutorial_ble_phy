# BLE Peripheral PHY Example Walkthrough

## Introduction

In this tutorial, the ble_phy peripheral example code for the espressif chipsets with BLE5.0 support is reviewed. This example aims at understanding how to establish connections on preferred PHY and changing LE PHY once the connection is established. The code implements a BLE Central PHY, which establishes a connection on LE 1M PHY and switches to LE 2M PHY once the connection is established. The Central then performs GATT read operation against a specified peer and disconnects once this is completed.

## Includes

This example is located in the examples folder of the ESP-IDF under the [ble_phy/phy_cent/main](https://github.com/espressif/esp-idf/tree/master/examples/bluetooth/nimble/ble_phy/phy_cent/). The [main.c](https://github.com/espressif/esp-idf/tree/master/examples/bluetooth/nimble/ble_phy/phy_cent/main/main.c) file located in the main folder contains all the functionality that we are going to review. The header files contained in [main.c](https://github.com/espressif/esp-idf/tree/master/examples/bluetooth/nimble/ble_phy/phy_cent/main/main.c) are:

```c
#include "esp_log.h"
#include "nvs_flash.h"

/* BLE */
#include "nimble/nimble_port.h"
#include "nimble/nimble_port_freertos.h"
#include "host/ble_hs.h"
#include "host/util/util.h"
#include "console/console.h"
#include "services/gap/ble_svc_gap.h"
#include "phy_cent.h"

```

These `includes` are required for the FreeRTOS and underlying system components to run, including the logging functionality and a library to store data in non-volatile flash memory. We are interested in `“nimble_port.h”`, `“nimble_port_freertos.h”`, `"ble_hs.h"` and `“ble_svc_gap.h”`, `“phy_cent.h”` which expose the BLE APIs required to implement this example.

* `nimble_port.h`: Includes the declaration of functions required for the initialization of the nimble stack.
* `nimble_port_freertos.h`: initializes and enables nimble host task.
* `ble_hs.h`: Defines the functionalities to handle the host event
* `ble_svc_gap.h`:
* `phy_cenr.h`:

## Main Entry Point

The program’s entry point is the app_main() function:

```c
void
app_main(void)
{
     int rc;

    /* Initialize NVS — it is used to store PHY calibration data */
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    //ESP_ERROR_CHECK(esp_nimble_hci_and_controller_init());

    nimble_port_init();
    /* Initialize the NimBLE host configuration. */
    ble_hs_cfg.reset_cb = bleprph_on_reset;
    ble_hs_cfg.sync_cb = bleprph_on_sync;
    ble_hs_cfg.gatts_register_cb = gatt_svr_register_cb;
    ble_hs_cfg.store_status_cb = ble_store_util_status_rr;

    ble_hs_cfg.sm_io_cap = CONFIG_EXAMPLE_IO_TYPE;
  #ifdef CONFIG_EXAMPLE_BONDING
    ble_hs_cfg.sm_bonding = 1;
  #endif
  #ifdef CONFIG_EXAMPLE_MITM
    ble_hs_cfg.sm_mitm = 1;
  #endif
  #ifdef CONFIG_EXAMPLE_USE_SC
    ble_hs_cfg.sm_sc = 1;
  #else
    ble_hs_cfg.sm_sc = 0;
  #endif
  #ifdef CONFIG_EXAMPLE_BONDING
    ble_hs_cfg.sm_our_key_dist = 1;
    ble_hs_cfg.sm_their_key_dist = 1;
  #endif

    rc = gatt_svr_init_le_phy();
    assert(rc == 0);

    /* Set the default device name. */
    rc = ble_svc_gap_device_name_set("bleprph-phy");
    assert(rc == 0);

    /* XXX Need to have template for store */
    ble_store_config_init();

    nimble_port_freertos_init(bleprph_host_task);

    /* Initialize command line interface to accept input from user */
    rc = scli_init();
    if (rc != ESP_OK) {
        ESP_LOGE(tag, "scli_init() failed");
    }

}

```

The main function starts by initializing the non-volatile storage library. This library allows to save key-value pairs in flash memory and is used by some components such as the Wi-Fi library to save the SSID and password:

```c
esp_err_t ret = nvs_flash_init();
if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
    ESP_ERROR_CHECK(nvs_flash_erase());
    ret = nvs_flash_init();
}
ESP_ERROR_CHECK( ret );
```

## BT Controller and Stack Initialization
The main function calls `nimble_port_init()` to initialize BT Controller and nimble stack. This function initializes the BT controller by first creating its configuration structure named `esp_bt_controller_config_t` with default settings generated by the `BT_CONTROLLER_INIT_CONFIG_DEFAULT()` macro. It implements the Host Controller Interface (HCI) on the controller side, the Link Layer (LL), and the Physical Layer (PHY). The BT Controller is invisible to the user applications and deals with the lower layers of the BLE stack. The controller configuration includes setting the BT controller stack size, priority, and HCI baud rate. With the settings created, the BT controller is initialized and enabled with the `esp_bt_controller_init()` and `esp_bt_controller_enable()` functions:

```c
esp_bt_controller_config_t config_opts = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
ret = esp_bt_controller_init(&config_opts);
```

Next, the controller is enabled in BLE Mode. 

```c
ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
```
>The controller should be enabled in `ESP_BT_MODE_BLE` if you want to use the BLE mode.
 
There are four Bluetooth modes supported:

1. `ESP_BT_MODE_IDLE`: Bluetooth not running
2. `ESP_BT_MODE_BLE`: BLE mode
3. `ESP_BT_MODE_CLASSIC_BT`: BT Classic mode
4. `ESP_BT_MODE_BTDM`: Dual mode (BLE + BT Classic)

After the initialization of the BT controller, the nimble stack, which includes the common definitions and APIs for BLE, is initialized by using `esp_nimble_init()`:

```c
esp_err_t esp_nimble_init(void)
{

#if !SOC_ESP_NIMBLE_CONTROLLER
    /* Initialize the function pointers for OS porting */
    npl_freertos_funcs_init();

    npl_freertos_mempool_init();

    if(esp_nimble_hci_init() != ESP_OK) {
        ESP_LOGE(NIMBLE_PORT_LOG_TAG, "hci inits failed\n");
        return ESP_FAIL;
    }
        
    /* Initialize default event queue */
    ble_npl_eventq_init(&g_eventq_dflt);

    os_msys_init();

    void ble_store_ram_init(void); 
    /* XXX Need to have template for store */
    ble_store_ram_init();
#endif

    /* Initialize the host */
    ble_hs_init();
    return ESP_OK;
}

```

The host is configured by setting up the callbacks for Stack-reset, Stack-sync, and Storage status

```c
 ble_hs_cfg.reset_cb = blecent_on_reset;
 ble_hs_cfg.sync_cb = blecent_on_sync;
 ble_hs_cfg.store_status_cb = ble_store_util_status_rr;
 ```
 
 


## Intializaion of LE PHY to Default 1M dataspeed.
 1M PHY is deafault PHY for BLE devices which enables it to provides data rate of 1 Mbps.It is used while establishing connection between divices and maintians the backword comapability with all those divises who dont have BLE5.0 support.`set_default_le_phy_before_conn()` function set default LE PHY before establishing connection.

```c
void set_default_le_phy_before_conn(uint8_t tx_phys_mask, uint8_t rx_phys_mask)
 {
    int rc = ble_gap_set_prefered_default_le_phy(tx_phys_mask, rx_phys_mask);
     if (rc == 0) {         MODLOG_DFLT(INFO, "Default LE PHY set successfully; tx_phy = %d, rx_phy = %d",
                     tx_phys_mask, rx_phys_mask);
     } else {
         MODLOG_DFLT(ERROR, "Failed to set default LE PHY");
     }
 }
 
 ```

## Setting LE PHY to 2M dataspeed .

2M PHY is introduced in BLE5.0 to increased the symbol rate at the physical layer.It provides a symbol rate of 2 Mega symbols per seconds where each symbol corresponds to single bit.This allows the user to to double the number of bits sent over the air during a given period , or conversly reduce energy consumption for a given amount od data by having the necessary transmit time. 

Below lines changes default LE PHY to 2M PHY.

` tx_phys_mask = BLE_HCI_LE_PHY_2M_PREF_MASK`
` rx_phys_mask = BLE_HCI_LE_PHY_2M_PREF_MASK` 

```c
void set_prefered_le_phy_after_conn(uint16_t conn_handle)
  {
      uint8_t tx_phys_mask = 0, rx_phys_mask = 0;
  
     tx_phys_mask = BLE_HCI_LE_PHY_2M_PREF_MASK;
 
     rx_phys_mask = BLE_HCI_LE_PHY_2M_PREF_MASK;
 
     int rc = ble_gap_set_prefered_le_phy(conn_handle, tx_phys_mask, rx_phys_mask,0);
     if (rc == 0) {
         MODLOG_DFLT(INFO, "Prefered LE PHY set to LE_PHY_2M successfully");
     } else {
         MODLOG_DFLT(ERROR, "Failed to set prefered LE_PHY_2M");
     }
 }
 ```
 
   
   

## Read Operation

```c
blecent_read(const struct peer *peer)
  {   
      const struct peer_chr *chr;
      int rc;
      
      /* Read the supported-new-alert-category characteristic. */
      chr = peer_chr_find_uuid(peer,
                               BLE_UUID16_DECLARE(LE_PHY_UUID16),
                               BLE_UUID16_DECLARE(LE_PHY_CHR_UUID16));
      if (chr == NULL) {
          MODLOG_DFLT(ERROR, "Error: Peer doesn't support the Supported "
                      "LE PHY characteristic\n");
          goto err;
      }
      
      rc = ble_gattc_read(peer->conn_handle, chr->chr.val_handle,
                          NULL, NULL);
      if (rc != 0) {
          MODLOG_DFLT(ERROR, "Error: Failed to read characteristic; rc=%d\n",
                      rc);
          goto err;
      }
  
      return;
  err:
      /* Terminate the connection. */
      ble_gap_terminate(peer->conn_handle, BLE_ERR_REM_USER_CONN_TERM);
  }
  ```
















